-- Neutron Pile Production Dashboard (Avaritia) - Drawer monitor
-- cc:Tweaked / ComputerCraft
-- Tracks "avaritia:neutron_pile" inside a Functional Storage drawer
-- Graphs: delta per second + delta per minute

--------------------------
-- CONFIG (ADAPT HERE)
--------------------------
local DRAWER_NAME  = "functionalstorage:jungle_1_0"
local MONITOR_NAME = "monitor_11"               -- set nil to use terminal
local ITEM_MATCH   = "avaritia:neutron_pile"    -- EXACT item name from your drawer

-- Graph history
local SEC_HISTORY = 60        -- last 60 seconds
local MIN_HISTORY = 60        -- last 60 minutes
local SAMPLE_SEC  = 1         -- sample every 1 second

-- Expected production check (items per minute). Set 0 to disable.
local EXPECTED_PER_MIN = 0
local UNDERPERF_RATIO  = 0.70

-- Alerts
local ZERO_PROD_SEC_LIMIT = 20

-- Runtime control
local CONTINUE_COLLECTING = true -- toggle with key 'c'

--------------------------
-- Helpers
--------------------------
local function clamp(v, a, b)
  if v < a then return a end
  if v > b then return b end
  return v
end

local function avg(tbl)
  if #tbl == 0 then return 0 end
  local s = 0
  for i=1,#tbl do s = s + tbl[i] end
  return s / #tbl
end

local function maxAbs(tbl)
  local m = 0
  for i=1,#tbl do
    local v = math.abs(tbl[i])
    if v > m then m = v end
  end
  return m
end

local function nowSec()
  return os.epoch("utc") / 1000
end

--------------------------
-- Peripheral init
--------------------------
local drawer = peripheral.wrap(DRAWER_NAME)
if not drawer then error("Drawer peripheral not found: "..tostring(DRAWER_NAME)) end

local out
if MONITOR_NAME then
  out = peripheral.wrap(MONITOR_NAME)
  if not out then error("Monitor not found: "..tostring(MONITOR_NAME)) end
  out.setTextScale(0.5)
else
  out = term
end

local function clear()
  out.setBackgroundColor(colors.black)
  out.setTextColor(colors.white)
  out.clear()
  out.setCursorPos(1,1)
end

--------------------------
-- Read stats from drawer
--------------------------
-- matchCount = qty of ITEM_MATCH
-- matchName  = exact name found
-- allCount   = total qty of all items
-- slotsUsed  = occupied slots
-- slotsMax   = highest slot index seen
local function getDrawerStats()
  local items = drawer.list()
  local matchCount, allCount = 0, 0
  local slotsUsed, slotsMax = 0, 0
  local matchName = nil

  for slot, it in pairs(items) do
    if type(slot) == "number" and slot > slotsMax then
      slotsMax = slot
    end
    if it and it.name then
      slotsUsed = slotsUsed + 1
      allCount = allCount + (it.count or 0)
      if it.name == ITEM_MATCH then
        matchCount = matchCount + (it.count or 0)
        matchName = it.name
      end
    end
  end

  if slotsMax < 1 then slotsMax = 1 end
  return matchCount, matchName, allCount, slotsUsed, slotsMax
end

--------------------------
-- Graph rendering
--------------------------
local function drawGraph(x, y, w, h, series, title, colorTitle)
  -- safe scale
  local m = maxAbs(series)
  if m < 1 then m = 1 end

  -- Title
  out.setCursorPos(x, y)
  out.setTextColor(colorTitle or colors.cyan)
  local t = title
  if #t > w then t = t:sub(1, w) end
  out.write(t .. string.rep(" ", math.max(0, w - #t)))

  local top = y + 1
  local bottom = y + h

  -- Clear area
  out.setTextColor(colors.gray)
  for row = top, bottom do
    out.setCursorPos(x, row)
    out.write(string.rep(" ", w))
  end

  -- Zero line (ASCII '-' ONLY)
  local zeroRow = top + math.floor((h - 1) / 2)
  out.setTextColor(colors.gray)
  out.setCursorPos(x, zeroRow)
  out.write(string.rep("-", w))

  -- Draw points (last w columns)
  local start = math.max(1, #series - w + 1)
  local col = 0
  for i = start, #series do
    col = col + 1
    local v = series[i]
    local norm = v / m
    local rowOffset = math.floor(norm * ((h - 1) / 2))
    local r = clamp(zeroRow - rowOffset, top, bottom)

    out.setCursorPos(x + col - 1, r)
    if v >= 0 then
      out.setTextColor(colors.lime)
      out.write("|")
    else
      out.setTextColor(colors.red)
      out.write("|")
    end
  end

  -- Scale line
  out.setTextColor(colors.lightGray)
  out.setCursorPos(x, bottom + 1)
  local legend = ("scale +/- %d"):format(m)
  if #legend > w then legend = legend:sub(1, w) end
  out.write(legend .. string.rep(" ", math.max(0, w - #legend)))
end

--------------------------
-- State
--------------------------
local secSeries = {}
local minSeries = {}
local lastCount = nil
local lastMinMark = nil
local minAccum = 0
local zeroProdSec = 0

--------------------------
-- Keys
--------------------------
local function handleKey(e, key)
  if e == "key" then
    if key == keys.c then
      CONTINUE_COLLECTING = not CONTINUE_COLLECTING
    elseif key == keys.q then
      clear()
      error("Stopped by user (q).")
    end
  end
end

--------------------------
-- Main loop
--------------------------
clear()

while true do
  local t0 = nowSec()

  local count, realName, allCount, slotsUsed, slotsMax = getDrawerStats()

  if not lastCount then
    lastCount = count
    lastMinMark = t0
  end

  -- delta per second
  local delta = count - lastCount
  lastCount = count

  if CONTINUE_COLLECTING then
    table.insert(secSeries, delta)
    if #secSeries > SEC_HISTORY then table.remove(secSeries, 1) end
    minAccum = minAccum + delta
  else
    table.insert(secSeries, 0)
    if #secSeries > SEC_HISTORY then table.remove(secSeries, 1) end
  end

  -- minute tick
  local elapsedMin = t0 - lastMinMark
  if elapsedMin >= 60 then
    table.insert(minSeries, minAccum)
    if #minSeries > MIN_HISTORY then table.remove(minSeries, 1) end
    minAccum = 0
    lastMinMark = lastMinMark + (math.floor(elapsedMin / 60) * 60)
  end

  -- Alerts
  if CONTINUE_COLLECTING then
    if delta <= 0 then zeroProdSec = zeroProdSec + 1 else zeroProdSec = 0 end
  else
    zeroProdSec = 0
  end

  local avgMin = avg(minSeries)
  local underperf = false
  if EXPECTED_PER_MIN > 0 and #minSeries >= 3 then
    underperf = (avgMin < (EXPECTED_PER_MIN * UNDERPERF_RATIO))
  end

  -- Draw UI
  local w, h = out.getSize()
  clear()

  out.setCursorPos(1,1)
  out.setTextColor(colors.white)
  out.write("NEUTRON PILE - DASHBOARD")

  out.setCursorPos(1,2)
  out.setTextColor(colors.lightGray)
  local status = CONTINUE_COLLECTING and "ON" or "PAUSE"
  local line2 = ("Item: %s"):format(tostring(realName or ITEM_MATCH))
  out.write(line2:sub(1, w))

  out.setCursorPos(1,3)
  out.setTextColor(colors.lightGray)
  local line3 = ("Drawer(neutron_pile): %d | Slots: %d/%d | Mode: %s (c toggle, q quit)")
    :format(count, slotsUsed, slotsMax, status)
  out.write(line3:sub(1, w))

  out.setCursorPos(1,4)
  out.setTextColor(colors.white)
  local line4 = ("Delta/s: %+d | Buffer(min): %+d | Drawer(all): %d")
    :format(delta, minAccum, allCount)
  out.write(line4:sub(1, w))

  local alertMsg, alertColor
  if zeroProdSec >= ZERO_PROD_SEC_LIMIT then
    alertMsg = "ALERTE: PRODUCTION NULLE (verifie route->drawer / lock / bus ME)"
    alertColor = colors.red
  elseif underperf then
    alertMsg = ("ALERTE: SOUS-PROD (moy %.1f/min < %.1f/min)"):format(avgMin, EXPECTED_PER_MIN)
    alertColor = colors.orange
  else
    alertMsg = "OK: production normale"
    alertColor = colors.lime
  end

  out.setCursorPos(1,5)
  out.setTextColor(alertColor)
  out.write(alertMsg:sub(1, w))

  -- Graph layout
  local graphTop = 7
  local graphHeight = math.floor((h - graphTop - 2) / 2)
  if graphHeight < 4 then graphHeight = 4 end

  drawGraph(1, graphTop, w, graphHeight, secSeries,
    "GRAPH: Delta / SECOND (last "..SEC_HISTORY.."s)", colors.cyan)

  drawGraph(1, graphTop + graphHeight + 2, w, graphHeight, minSeries,
    "GRAPH: Delta / MINUTE (last "..MIN_HISTORY.."m)", colors.yellow)

  -- Wait + handle keys
  local timer = os.startTimer(SAMPLE_SEC)
  while true do
    local e, p1 = os.pullEvent()
    if e == "timer" and p1 == timer then break end
    handleKey(e, p1)
  end
end
